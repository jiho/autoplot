% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ordination_scores.R
\name{scores}
\alias{scores}
\alias{scores.CA}
\alias{scores.PCA}
\alias{scores.ca}
\alias{scores.correspondence}
\alias{scores.pca}
\alias{scores.pcaRes}
\alias{scores.prcomp}
\alias{scores.rda}
\title{Extract scores from an ordination object}
\usage{
scores(x, type = "rows", scaling = type, ...)

\method{scores}{prcomp}(x, type = "rows", scaling = type, ...)

\method{scores}{PCA}(x, type = "rows", scaling = type, ...)

\method{scores}{rda}(x, type = "rows", scaling = type, ...)

\method{scores}{pca}(x, type = "rows", scaling = type, ...)

\method{scores}{pcaRes}(x, type = "rows", scaling = type, ...)

\method{scores}{CA}(x, type = "rows", scaling = type, ...)

\method{scores}{correspondence}(x, type = "rows", scaling = type, ...)

\method{scores}{ca}(x, type = "rows", scaling = type, ...)
}
\arguments{
\item{x}{an object returned by an ordination function.}

\item{type}{the scores (i.e. coordinates in the new space) to extract: either "rows", "lines", "observations", "objects", "individuals", "sites" (which are all treated as synonyms) or "columns", "variables", "descriptors", "species" (which are, again, synonyms). All can be abbreviated. By default, scores of rows are returned.}

\item{scaling}{scaling for the scores. Can be
\describe{
  \item{"none" (or 0)}{for raw scores,}
  \item{"rows" (or 1, or a synonym of "rows")}{to scale row scores by the eigenvalues,}
  \item{"column" (or 2, or a synonym of "column")}{to scale column scores by the eigenvalues,}
  \item{"both" (or 3)}{to scale both row and column scores.}
}
By default, scaling is adapted to the type of scores extracted (scaling 1 for row scores and scaling 2 for column scores).}
}
\description{
Extract scores from an ordination object
}
\details{
Scaling of scores follows the conventions of package \code{vegan}. In summary, except for scaling 0, scores are all multiplied by a constant:
\deqn{c = \sqrt[4]{(n-1) \times \sum{eig}}}{c = sqrt(sqrt((n-1) * sum(eigenvalues)))}
where \eqn{n} is the number of active rows in the ordination and \eqn{eig} are the eigenvalues (see function \code{\link{eigenvalues}}).
In addition, for scaling 1 (resp. 2), row scores (resp. column scores) are multiplied by:
\deqn{\sqrt{\frac{eig}{\sum{eig}}}}{sqrt(eig/sum(eig))}
For scaling 3, both row and column scores are multiplied by:
\deqn{\sqrt[4]{\frac{eig}{\sum{eig}}}}{sqrt(sqrt(eig/sum(eig)))}
For details and justification, see \code{vignette("decision-vegan")}.
}
\examples{
# Principal Component Analysis
pca <- prcomp(USArrests, scale=TRUE)
head(scores(pca))
head(scores(pca, type="columns"))
head(scores(pca, type="columns", scaling=0))
head(scores(pca, type="columns", scaling=3))

sc <- scores(pca)
plot(sc$PC1, sc$PC2, asp=1)
text(sc$PC1, sc$PC2, label=sc$label, adj=c(-0.1,0.5))

if (require("FactoMineR")) {
  head(scores(PCA(USArrests, graph=F)))
}
if (require("vegan")) {
  head(scores(rda(USArrests, scale=TRUE)))
}
if (require("ade4")) {
  head(scores(dudi.pca(USArrests, scannf=FALSE, nf=4)))
}
if (require("pcaMethods")) {
  head(scores(pca(USArrests, scale="uv", nPcs=4)))
}

# Correspondence analysis
clr <- HairEyeColor[,,1]
if (require("FactoMineR")) {
  CA.res <- CA(clr, graph=F)
  scores(CA.res, type="row", scaling="none")
  scores(CA.res, type="col", scaling="none")
  # for a correspondence analysis, scaling="both" makes most sense
  scores(CA.res, type="row", scaling="both")
  scores(CA.res, type="col", scaling="both")
}
if (require("MASS")) {
  corresp.res <- corresp(clr, nf=3)
  scores(corresp.res, type="row", scaling="both")
  scores(corresp.res, type="col", scaling="both")
}
if (require("ca")) {
  ca.res <- ca(clr, nf=3)
  scores(corresp.res, type="row", scaling="both")
  scores(corresp.res, type="col", scaling="both")
}

}

