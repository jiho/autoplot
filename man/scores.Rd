% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ordination_scores.R
\name{scores}
\alias{scores}
\alias{scores.CA}
\alias{scores.PCA}
\alias{scores.ca}
\alias{scores.correspondence}
\alias{scores.pca}
\alias{scores.pcaRes}
\alias{scores.prcomp}
\alias{scores.rda}
\title{Extract scores from an ordination object}
\usage{
scores(x, which = "rows", scaling = which, ...)

\method{scores}{prcomp}(x, which = "rows", scaling = which, ...)

\method{scores}{PCA}(x, which = "rows", scaling = which, ...)

\method{scores}{rda}(x, which = "rows", scaling = which, ...)

\method{scores}{pca}(x, which = "rows", scaling = which, ...)

\method{scores}{pcaRes}(x, which = "rows", scaling = which, ...)

\method{scores}{CA}(x, which = "rows", scaling = which, ...)

\method{scores}{correspondence}(x, which = "rows", scaling = which, ...)

\method{scores}{ca}(x, which = "rows", scaling = which, ...)
}
\arguments{
\item{x}{an object returned by an ordination function.}

\item{which}{the scores (i.e. coordinates in the new space) to extract: either "rows", "lines", "observations", "objects", "individuals", "sites" (which are all treated as synonyms) or "columns", "variables", "descriptors", "species" (which are, again, synonyms). All can be abbreviated. By default, scores of rows are returned.}

\item{scaling}{scaling for the scores. Can be
\describe{
  \item{"none" (or 0)}{for raw scores,}
  \item{"rows" (or 1, or a synonym of "rows")}{to scale row scores by the eigenvalues,}
  \item{"columns" (or 2, or a synonym of "columns")}{to scale column scores by the eigenvalues,}
  \item{"both" (or 3)}{to scale both row and column scores.}
}
By default, scaling is adapted to the type of scores extracted (scaling 1 for row scores, scaling 2 for column scores, and scaling 3 when scores are extracted for a biplot).}
}
\value{
A data.frame containing
\describe{
  \item{PC#:}{the scores (i.e., coordinates) of the data objects on the new dimensions.}
  \item{rownames:}{the identifier of the row or column, extracted from the row or column names in the original data.}
  \item{type:}{the nature of the data extracted : \code{row} or \code{col}.}
}
}
\description{
Extract scores from an ordination object
}
\details{
Scaling of scores follows the conventions of package \code{vegan}. In summary, except for scaling 0, scores are all multiplied by a constant:
\deqn{c = \sqrt[4]{(n-1) \times \sum{eig}}}{c = sqrt(sqrt((n-1) * sum(eig)))}
where \eqn{n} is the number of active rows in the ordination and \eqn{eig} are the eigenvalues (see function \code{\link{eigenvalues}}).
In addition, for scaling 1 (resp. 2), row scores (resp. column scores) are multiplied by:
\deqn{\sqrt{\frac{eig}{\sum{eig}}}}{sqrt(eig/sum(eig))}
For scaling 3, both row and column scores are multiplied by:
\deqn{\sqrt[4]{\frac{eig}{\sum{eig}}}}{sqrt(sqrt(eig/sum(eig)))}
For details and justification, see \code{vignette("decision-vegan")}.
}
\examples{
# Principal Component Analysis
pca <- prcomp(USArrests, scale=TRUE)
head(scores(pca))
head(scores(pca, which="columns"))
head(scores(pca, which="columns", scaling=0))
head(scores(pca, which="columns", scaling=3))

sc <- scores(pca)
plot(sc$PC1, sc$PC2, asp=1)
text(sc$PC1, sc$PC2, label=sc$rownames, adj=c(-0.1,0.5))

if (require("FactoMineR")) {
  head(scores(PCA(USArrests, graph=F)))
}
if (require("vegan")) {
  head(scores(rda(USArrests, scale=TRUE)))
}
if (require("ade4")) {
  head(scores(dudi.pca(USArrests, scannf=FALSE, nf=4)))
}
if (require("pcaMethods")) {
  head(scores(pca(USArrests, scale="uv", nPcs=4)))
}

# Correspondence analysis
clr <- HairEyeColor[,,1]
if (require("FactoMineR")) {
  CA.res <- CA(clr, graph=F)
  scores(CA.res, which="row", scaling="none")
  scores(CA.res, which="col", scaling="none")
  # for a correspondence analysis, scaling="both" makes most sense
  scores(CA.res, which="row", scaling="both")
  scores(CA.res, which="col", scaling="both")
}
if (require("MASS")) {
  corresp.res <- corresp(clr, nf=3)
  scores(corresp.res, which="row", scaling="both")
  scores(corresp.res, which="col", scaling="both")
}
if (require("ca")) {
  ca.res <- ca(clr, nf=3)
  scores(corresp.res, which="row", scaling="both")
  scores(corresp.res, which="col", scaling="both")
}

}
\seealso{
Functions to perform PCA: \code{\link[stats]{prcomp}} in package \code{stats}, \code{\link[FactoMineR]{PCA}} in package \code{factoMineR}, \code{\link[vegan]{rda}} in package \code{vegan}, \code{\link[ade4]{dudi.pca}} in package \code{ade4}, \code{\link[pcaMethods]{pca}} in package \code{pcaMethods} (on bioconductor).

Functions to perform CA: \code{\link[FactoMineR]{CA}} in package \code{factoMineR}, \code{\link[MASS]{corresp}} in package \code{MASS}, \code{\link[ca]{ca}} in package \code{ca}.

Other CA-related functions: \code{\link{eigenvalues}}

Other PCA-related functions: \code{\link{autoplot_pca}},
  \code{\link{eigenvalues}}, \code{\link{pca_tidiers}}
}

